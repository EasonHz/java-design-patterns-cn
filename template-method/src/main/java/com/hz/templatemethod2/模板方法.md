# 模板方法

## 介绍

​	在面向对象编程中，模板方法是行为设计模式之一。模板方法通常是一个抽象超类，它定义了操作框架的许多高级步骤。并将一些步骤推迟到子类。
​	模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。
​	模板方法概述了父类中的一般步骤，并允许具体的子实现定义细节。

## 实现

案例：使用模板法设计模式的汽车制造实例

首先，我们定义一个抽象类来表示汽车制造模板。以下是CarTemplate类的代码：

```java
public abstract class CarTemplate {

    protected String chassis;
    protected String body;
    protected String paint;
    protected String interior;

    public CarTemplate() {
        super();
    }

    /**
     * 造底盘
     */
    public abstract void fixChassis();

    /**
     * 造车体
     */
    public abstract void fixBody();

    /**
     * 喷油漆
     */
    public abstract void paint();

    /**
     * 装内饰
     */
    public abstract void fixInterior();

    /**
     * 模板方法
     */
    public void manufactureCar() {
        fixChassis();
        fixBody();
        paint();
        fixInterior();
    }

    @Override
    public String toString() {
        return "Car [chassis=" + chassis + ", body=" + body + ", paint=" + paint +
                ", interior=" + interior + "]";
    }

}
```

这里请注意，`manufactureCar（）`方法是这里的模板方法。方法`fixChassis（）`、`fixBody（）`、`paint（）`和`fixInterior（）`是将由不同子类定义的步骤。模板方法定了算法的执行步骤。

现在我们将实现具体的子类来定义不同风格的模板。

下面是`ClassicCar`的代码示例：

```java
public class ClassicCar extends CarTemplate {

    public ClassicCar() {
        super();
    }

    @Override

    public void fixChassis() {
        System.out.println("装配经典车型的底盘");
        this.chassis = "Classic Chassis";
    }

    @Override
    public void fixBody() {
        System.out.println("装配经典车型的车体");
        this.body = "Classic Body";
    }

    @Override
    public void paint() {
        System.out.println("喷上白色车漆...");
        this.paint = "Classic White Paint";
    }

    @Override
    public void fixInterior() {
        System.out.println("安装经典车型的内饰...");
        this.interior = "Classic interior";
    }

}
```

下面是`ModernCar`代码示例：

```java
public class ModernCar extends CarTemplate {

    public ModernCar() {
        super();
    }

    @Override

    public void fixChassis() {
        System.out.println("装配现代车型底盘");
        this.chassis = "Modern Chassis";
    }

    @Override
    public void fixBody() {
        System.out.println("装配现代车型车体");
        this.body = "Modern Body";
    }

    @Override
    public void paint() {
        System.out.println("喷上黑色油漆");
        this.paint = "Modern Black Paint";
    }

    @Override
    public void fixInterior() {
        System.out.println("安装现代车型内饰");
        this.interior = "Modern interior";
    }
}

```

下面是`SportsCar`代码示例：

```java
public class SportsCar extends CarTemplate {

    public SportsCar() {
        super();
    }

    @Override
    public void fixChassis() {
        System.out.println("装配运动车型底盘");
        this.chassis = "Sporty Chassis";
    }

    @Override
    public void fixBody() {
        System.out.println("装配运动车型车体");
        this.body = "Sporty Body";
    }

    @Override
    public void paint() {
        System.out.println("给运动车型喷上红色油漆");
        this.paint = "Sporty Torch Red Paint";
    }

    @Override
    public void fixInterior() {
        System.out.println("安装运动车型内饰");
        this.interior = "Sporty interior";
    }
}
```

执行和测试程序`Main`

```java
public class Main {
    public static void main(String[] args) {
        CarTemplate car = new SportsCar();
        car.manufactureCar();
        System.out.println("装配好的车辆信息: ");
        System.out.println("======================================================================");
        System.out.println(car);
        System.out.println("======================================================================");
    }
}
```

程序输出结果

```java
装配运动车型底盘
装配运动车型车体
给运动车型喷上红色油漆
安装运动车型内饰
装配好的车辆信息: 
======================================================================
Car [chassis=Sporty Chassis, body=Sporty Body, paint=Sporty Torch Red Paint, interior=Sporty interior]
======================================================================
```



## 总结

**优点**

1. 封装不变部分，扩展可变部分。
2. 提取公共代码，便于维护。 
3. 行为由父类控制，子类实现。

**缺点**

1. 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

**使用场景**

1. 有多个子类共有的方法，且逻辑相同。
2. 重要的、复杂的方法，可以考虑作为模板方法。

**注意事项**

为防止恶意操作，一般模板方法都加上 final 关键词。

**经典案例**

[javax.servlet.GenericServlet.init](https://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/GenericServlet.html#init--):

```java
    @Override
    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        this.init();
    }
    public void init() throws ServletException {
        // NOOP by default
    }
```

方法`GenericServlet.init（ServletConfig config）`调用无参方法`GenericServlet.init（）`打算在子类中重写。
方法`GenericServlet.init（ServletConfig config）`就是本例中的模板方法。





