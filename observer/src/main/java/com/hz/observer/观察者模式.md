# 观察者模式

## 介绍

​	今天，我将讨论简单且非常有用的行为设计模式，称为观察者设计模式。当我们想要得到关于对象状态更改的通知时，此设计模式非常有用。
​	观察者设计模式在Subject（Observable）和它的依赖者（Observer）之间保持一对多的依赖关系，这样每当Subject的状态发生变化，它的依赖方就会得到通知。
​	观察者模式定义了对象之间的一对多依赖关系，以便在一个对象更改状态时，自动通知和更新其所有依赖项。

## 实现

**案例**
	在一片遥远的土地上生活着霍比特人和兽人种族。它们大多都在室外，因此它们密切关注天气变化。

首先是`WeatherObserver` 接口代码示例

```java
/**
 * 观察者接口
 *
 * @author hz
 */
public interface WeatherObserver {

    /**
     * 被观察者转态发生变化时，通知观察者
     *
     * @param currentWeather 天气类型
     */
    void update(WeatherType currentWeather);

}
```

下面是种族类兽人`Orcs` 和霍比特人`Hobbits`，并实现了`WeatherObserver`接口，成为天气的观察者

```java
@Slf4j
public class Orcs implements WeatherObserver {

    @Override
    public void update(WeatherType currentWeather) {
        LOGGER.info("兽人现在面临着 {} 的天气", currentWeather.getDescription());
    }
}

@Slf4j
public class Hobbits implements WeatherObserver {

    @Override
    public void update(WeatherType currentWeather) {
        LOGGER.info("霍比特人现在面临着 {} 的天气", currentWeather.getDescription());
    }
}
```

然后，我们定义天气的枚举类`WeatherType`

```java
public enum WeatherType {

    /**
     * 天气类型枚举
     */
    SUNNY("Sunny"),
    RAINY("Rainy"),
    WINDY("Windy"),
    COLD("Cold");

    private final String description;

    WeatherType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return this.description;
    }

    @Override
    public String toString() {
        return this.name().toLowerCase();
    }
}
```

这是天气接口`Weather` ，随着时间的流逝天气一直在变化

```java
/**
 * Weather通过实现并注册{@link WeatherObserver}接口，来成为监听器
 * 被观察对象
 *
 * @author hz
 */
@Slf4j
public class Weather {

    private WeatherType currentWeather;
    private final List<WeatherObserver> observers;

    public Weather() {
        observers = new ArrayList<>();
        currentWeather = WeatherType.SUNNY;
    }

    public void addObserver(WeatherObserver obs) {
        observers.add(obs);
    }

    public void removeObserver(WeatherObserver obs) {
        observers.remove(obs);
    }

    /**
     * 随着时间的流逝，天气一直在变化
     */
    public void timePasses() {
        var enumValues = WeatherType.values();
        currentWeather = enumValues[(currentWeather.ordinal() + 1) % enumValues.length];
        LOGGER.info("The weather changed to {}.", currentWeather);
        notifyObservers();
    }

    private void notifyObservers() {
        for (var obs : observers) {
            obs.update(currentWeather);
        }
    }
}
```

最后是观察者模式的执行和测试程序`App`

```java
@Slf4j
public class App {

    public static void main(String[] args) {
        var weather = new Weather();
        weather.addObserver(new Orcs());
        weather.addObserver(new Hobbits());
        weather.timePasses();
        weather.timePasses();
        weather.timePasses();
        weather.timePasses();
    }
}
```

程序输出结果：

```java
11:30:39.000 [main] INFO com.hz.observer.Weather - 天气变成了 rainy.
11:30:39.003 [main] INFO com.hz.observer.Orcs - 兽人现在面临着 Rainy 的天气
11:30:39.003 [main] INFO com.hz.observer.Hobbits - 霍比特人现在面临着 Rainy 的天气
11:30:39.003 [main] INFO com.hz.observer.Weather - 天气变成了 windy.
11:30:39.003 [main] INFO com.hz.observer.Orcs - 兽人现在面临着 Windy 的天气
11:30:39.003 [main] INFO com.hz.observer.Hobbits - 霍比特人现在面临着 Windy 的天气
11:30:39.003 [main] INFO com.hz.observer.Weather - 天气变成了 cold.
11:30:39.003 [main] INFO com.hz.observer.Orcs - 兽人现在面临着 Cold 的天气
11:30:39.003 [main] INFO com.hz.observer.Hobbits - 霍比特人现在面临着 Cold 的天气
11:30:39.003 [main] INFO com.hz.observer.Weather - 天气变成了 sunny.
11:30:39.003 [main] INFO com.hz.observer.Orcs - 兽人现在面临着 Sunny 的天气
11:30:39.004 [main] INFO com.hz.observer.Hobbits - 霍比特人现在面临着 Sunny 的天气
```

## 总结

**优点**

1. 观察者和被观察者是抽象耦合的。
2. 建立一套触发机制，支持广播通讯。被观察者会向所有的登记过的观察者发出通知。

**缺点**

1.  如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2.  如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
3.  观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景**

- 当一个抽象模型有两个方面时，一个依赖于另一个。将这些方面封装在单独的对象中，可以独立地改变和重用它们。

- 当一个对象的更改需要更改其他对象时，您不知道需要更改多少个对象。

- 当一个对象应该能够通知其他对象而不必假设这些对象是谁时。换句话说，您不希望这些对象紧密耦合。

**注意事项**

- JAVA 中已经有了对观察者模式的支持类。 
- 避免循环引用。 
- 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

**经典案例**

* [java.util.Observer](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)
* [java.util.EventListener](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)
* [javax.servlet.http.HttpSessionBindingListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
* [RxJava](https://github.com/ReactiveX/RxJava)



















