## 介绍

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

## 实现

案例：用各种策略来计算账户中本金的利息。

因此，首先，我们必须创建一个接口来定义策略（算法）。下面是`InterestCalculationStrategy`策略接口

```java
/**
 * 利息计算策略类
 *
 * @author hz
 * @since 2022/10/11
 */
public interface InterestCalculationStrategy {
    /**
     * 计算利息
     *
     * @param principal 本金
     * @param rate      利率
     * @param term      期数
     * @return 利息
     */
    double calculateInterest(double principal, double rate, int term);
}

```

现在，我定义了两种类型的利息计算逻辑或策略算法，`SimpleInterestCalculator`用于计算给定期限的利率。

```java
**
 * 简单利息计算方法
 *
 * @author hz
 * @since 2022/10/11
 */
public class SimpleInterestCalculator implements InterestCalculationStrategy {

    @Override
    public double calculateInterest(final double principal, final double rate, final int term) {
        return ((principal * term * rate) / 100);
    }

    @Override
    public String toString() {
        return "简单利息计算";
    }

}
```

并且，我将使用`CompoundInterestCalculator`计算给定期限的复利。

```java
/**
 * 复杂利息计算方法
 *
 * @author hz
 * @since 2022/10/11
 */
public class CompoundInterestCalculator implements InterestCalculationStrategy {

    @Override
    public double calculateInterest(final double principal, final double rate, final int term) {
        return (principal * Math.pow(1.0 + rate / 100.0, term) - principal);
    }

    @Override
    public String toString() {
        return "复杂利息计算";
    }

}
```

我们有两种账户类型：储蓄账户或活期账户。利率是固定的，并根据此帐户类型定义。在这里，请注意，我已经根据账户类型确定了利率。

```java
**
 * 账户类型
 *
 * @author hz
 * @since 2022/10/11
 */
public enum AccountType {

    //储蓄账户
    SAVING(2.0d),
    //活期账户
    CURRENT(1.0d);
    /**
     * 利率
     */
    private final double rate;

    AccountType(final double rate) {
        this.rate = rate;
    }

    public double getRate() {
        return rate;
    }

}

```

然后定义一个账户类`Account`来保存账户信息

```java
@Data
public class Account {

    private long accountNo;
    private String accountHolderName;
    private AccountType accountType;
    private InterestCalculationStrategy interestStrategy;
    private double amount;

    public Account() {
        super();
    }

    public Account(long accountNo, String accountHolderName, AccountType accountType) {
        this();
        this.accountNo = accountNo;
        this.accountHolderName = accountHolderName;
        this.accountType = accountType;
    }


    public Account(long accountNo, String accountHolderName, AccountType accountType,
                   InterestCalculationStrategy interestStrategy) {
        this(accountNo, accountHolderName, accountType);
        this.interestStrategy = interestStrategy;
    }


    public void deposit(double amount) {
        //检查账户余额
        if (amount > 0.0d) {
            this.amount += amount;
        }
    }

    public void withdraw(double amount) {
        //检查账户余额
        if (amount > 0.0d && amount < this.amount) {
            this.amount -= amount;
        }
    }

    public double getInterest(int term) {
        if (getInterestStrategy() != null && getAccountType() != null) {
            return getInterestStrategy().calculateInterest(getAmount(), getAccountType().getRate(), term);
        }
        return 0.0d;
    }

    @Override
    public String toString() {
        return "账户 [accountNo=" + getAccountNo() +
                ", accountHolderName=" + getAccountHolderName() +
                ", accountType=" + getAccountType() +
                ", rate=" + ((getAccountType() != null) ? getAccountType().getRate() : 0.0d) +
                ", interestStrategy=" + getInterestStrategy() +
                ", amount=" + getAmount() + "]";
    }

}

```

最后编写测试程序`Main`代码

```java
public class Main {

    public static void main(String[] args) {
        Account acct1 = new Account(12345678L, "张三", AccountType.SAVING);
        acct1.setInterestStrategy(new CompoundInterestCalculator());
        acct1.deposit(10000.0d);
        System.out.println(acct1 + " 利息是: " + acct1.getInterest(5));

        Account acct2 = new Account(12345680L, "李四", AccountType.SAVING);
        acct2.setInterestStrategy(new SimpleInterestCalculator());
        acct2.deposit(10000.0d);
        System.out.println(acct2 + " 利息是: " + acct2.getInterest(5));
    }

}
```

程序输出结果

```java
账户 [accountNo=12345678, accountHolderName=张三, accountType=SAVING, rate=2.0, interestStrategy=复杂利息计算, amount=10000.0] 利息是: 1040.8080320000008
账户 [accountNo=12345680, accountHolderName=李四, accountType=SAVING, rate=2.0, interestStrategy=简单利息计算, amount=10000.0] 利息是: 1000.0

Process finished with exit code 0
```



## 总结

**优点** 

1. 算法可以自由切换。 
2. 避免使用多重条件判断。 
3. 扩展性良好。

**缺点** 

1. 策略类会增多。
2.  所有策略类都需要对外暴露。

**注意事项**

如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。











