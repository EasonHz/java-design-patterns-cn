## 介绍

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。

允许创建不同风格的对象，同时避免构造函数污染。当一个对象可能有多种风格时非常有用。或者当创建对象涉及到许多步骤时。

建造者模式创建型模式，其目的是为可伸缩的构建器反模式找到解决方案。
让我补充一下什么是伸缩构造函数反模式。在某一点上，我们都见过如下构造函数：

```java
public Hero(Profession profession, String name, HairType hairType, HairColor hairColor, Armor armor, Weapon weapon) {
}
```

正如看到的那样，构造函数参数的数量很快就会失控，并且可能很难理解参数的排列。如果以后想添加新的参数，此参数列表可能会继续增长。这称为伸缩构造函数反模式。

## 实现

案例：想象一下角色扮演游戏的角色生成器。最简单的选择是让计算机为您创建角色。如果要手动选择角色详细信息，如职业、性别、头发颜色等，则角色生成将成为一个循序渐进的过程，在所有选择就绪后完成。

代码示例👉源码地址](https://github.com/EasonHz/java-design-patterns-cn)

## 总结

**优点** 

- 建造者独立，易扩展
- 便于控制细节风险

**缺点** 

- 产品必须有共同点，范围有限制
-  如内部变化复杂，会有很多的建造类

**使用场景** 

- 创建复杂对象的算法应该独立于组成对象的各个部分及其组装方式

- 构造过程必须允许对构造的对象进行不同的表示
- 需要生成的对象具有复杂的内部结构
- 需要生成的对象内部属性本身相互依赖

**注意事项**

- 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

**经典案例**

* [java.lang.StringBuilder](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)
* [java.nio.ByteBuffer](http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-) as well as similar buffers such as FloatBuffer, IntBuffer and so on.
* [java.lang.StringBuffer](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-)
* All implementations of [java.lang.Appendable](http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html)
* [Apache Camel builders](https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder)
* [Apache Commons Option.Builder](https://commons.apache.org/proper/commons-cli/apidocs/org/apache/commons/cli/Option.Builder.html)













